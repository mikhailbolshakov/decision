// Code generated by mockery 2.14.0. DO NOT EDIT.

package mocks

import (
	kit "github.com/mikhailbolshakov/decision/kit"
	goroutine "github.com/mikhailbolshakov/decision/kit/goroutine"

	mock "github.com/stretchr/testify/mock"
)

// ErrGroup is an autogenerated mock type for the ErrGroup type
type ErrGroup struct {
	mock.Mock
}

// Cancel provides a mock function with given fields:
func (_m *ErrGroup) Cancel() {
	_m.Called()
}

// CancelFunc provides a mock function with given fields:
func (_m *ErrGroup) CancelFunc() func() {
	ret := _m.Called()

	var r0 func()
	if rf, ok := ret.Get(0).(func() func()); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// Cmp provides a mock function with given fields: component
func (_m *ErrGroup) Cmp(component string) goroutine.ErrGroup {
	ret := _m.Called(component)

	var r0 goroutine.ErrGroup
	if rf, ok := ret.Get(0).(func(string) goroutine.ErrGroup); ok {
		r0 = rf(component)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(goroutine.ErrGroup)
		}
	}

	return r0
}

// Go provides a mock function with given fields: f
func (_m *ErrGroup) Go(f func() error) {
	_m.Called(f)
}

// Mth provides a mock function with given fields: method
func (_m *ErrGroup) Mth(method string) goroutine.ErrGroup {
	ret := _m.Called(method)

	var r0 goroutine.ErrGroup
	if rf, ok := ret.Get(0).(func(string) goroutine.ErrGroup); ok {
		r0 = rf(method)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(goroutine.ErrGroup)
		}
	}

	return r0
}

// Wait provides a mock function with given fields:
func (_m *ErrGroup) Wait() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithLogger provides a mock function with given fields: logger
func (_m *ErrGroup) WithLogger(logger kit.CLogger) goroutine.ErrGroup {
	ret := _m.Called(logger)

	var r0 goroutine.ErrGroup
	if rf, ok := ret.Get(0).(func(kit.CLogger) goroutine.ErrGroup); ok {
		r0 = rf(logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(goroutine.ErrGroup)
		}
	}

	return r0
}

// WithLoggerFn provides a mock function with given fields: loggerFn
func (_m *ErrGroup) WithLoggerFn(loggerFn kit.CLoggerFunc) goroutine.ErrGroup {
	ret := _m.Called(loggerFn)

	var r0 goroutine.ErrGroup
	if rf, ok := ret.Get(0).(func(kit.CLoggerFunc) goroutine.ErrGroup); ok {
		r0 = rf(loggerFn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(goroutine.ErrGroup)
		}
	}

	return r0
}

type mockConstructorTestingTNewErrGroup interface {
	mock.TestingT
	Cleanup(func())
}

// NewErrGroup creates a new instance of ErrGroup. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewErrGroup(t mockConstructorTestingTNewErrGroup) *ErrGroup {
	mock := &ErrGroup{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
